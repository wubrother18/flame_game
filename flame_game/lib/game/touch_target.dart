import 'dart:math';
import 'dart:ui';

import 'package:flame/components.dart';
import 'package:flame/events.dart';
import 'package:flame/particles.dart';

class TapTarget extends PositionComponent with TapCallbacks{
  TapTarget() : super(anchor: Anchor.center);

  ///背景色
  final _paint = Paint()..color = const Color(0x448BA8FF);

  ///控制被加入的子元素(Component)的列表
  final Map<int, Spark> _circles = {};

  final Random _random = Random();

  @override
  void onGameResize(Vector2 canvasSize) {
    super.onGameResize(canvasSize);
    size = canvasSize;
    if (size.x < 100 || size.y < 100) {
      size = canvasSize;
    }
    position = canvasSize / 2;
  }

  @override
  void render(Canvas canvas) {
    canvas.drawRect(size.toRect(), _paint);
  }

  @override
  void onTapDown(TapDownEvent event) {
      createParticle(event.canvasPosition);
  }

  @override
  void onLongTapDown(TapDownEvent event) {

  }

  @override
  void onTapUp(TapUpEvent event) {
  }

  @override
  void onTapCancel(TapCancelEvent event) {
  }

  Vector2 randomVector() {
    Vector2 base = Vector2.random(_random); //  (0, 0) ~ (1, 1)
    Vector2 fix = Vector2(-0.5,-0.5);
    base = base + fix; //  (-0.5, -0.5) ~ (0.5, 0.5)
    return base * 200;

    // Vector2 base = Vector2.random(_random); //  (0, 0) ~ (1, 1)
    // Vector2 fix = Vector2(-0.5,0);
    // base = base + fix; // (-0.5, 0) ~ (0.5, 1)
    // return base * 200;
  }

  void createParticle(Vector2 position) {
    CircleParticle circleParticle = CircleParticle(
      radius: 1,
      paint: Paint()..color = const Color.fromARGB(255, 255, 200, 0),
    );

    Particle particle = Particle.generate(
      count: 100,
      lifespan: 10,
      generator: (i) =>
          AcceleratedParticle(
              child: circleParticle,
              acceleration: randomVector(),
              speed: randomVector(),
              position: position),
    );

    final ParticleSystemComponent psc =
    ParticleSystemComponent(particle: particle);
    add(psc);
  }

}

class Spark extends Component {
  Spark(this._center)
      : _baseColor = const Color.fromARGB(255, 255, 200, 0);

  final Color _baseColor;
  final Vector2 _center;
  double _outerRadius = 0;
  double _innerRadius = 0;
  bool _released = false;
  bool _cancelled = false;
  late final _paint = Paint()
    ..style = PaintingStyle.stroke
    ..color = _baseColor;

  /// "Accent" is thin white circle generated by `onLongTapDown`. We use
  /// negative radius to indicate that the circle should not be drawn yet.
  double _accentRadius = -1e10;
  late final _accentPaint = Paint()
    ..style = PaintingStyle.stroke
    ..strokeWidth = 0
    ..color = const Color(0xFFFFFFFF);

  /// At this radius the circle will disappear.
  static const maxRadius = 15;
  static final random = Random();

  double get radius => (_innerRadius + _outerRadius) / 2;

  void release() => _released = true;
  void cancel() => _cancelled = true;
  void accent() => _accentRadius = 0;

  @override
  void render(Canvas canvas) {
    canvas.drawCircle(_center.toOffset(), radius, _paint);
    if (_accentRadius >= 0) {
      // canvas.drawCircle(_center.toOffset(), _accentRadius, _accentPaint);
    }
  }

  @override
  void update(double dt) {
    if (_cancelled) {
      _innerRadius += dt * 100; // implosion
    } else {
      _outerRadius += dt * 20;
      _innerRadius += dt * (_released ? 20 : 6);
      _accentRadius += dt * 20;
    }
    if (radius >= maxRadius || _innerRadius > _outerRadius) {
      removeFromParent();
    } else {
      final opacity = 1 - radius / maxRadius;
      _paint.color = _baseColor.withOpacity(opacity);
      _paint.strokeWidth = _outerRadius - _innerRadius;
    }
  }
}